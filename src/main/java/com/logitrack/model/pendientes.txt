## **PASO 10 ‚Äì REPOSITORIOS PARA MOVIMIENTOS Y AUDITOR√çA**

### repository/MovimientoRepository.java

java

```jsx
package com.logitrack.repository;

import com.logitrack.model.Movimiento;
import com.logitrack.model.Usuario;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;

import java.time.LocalDateTime;
import java.util.List;

@Repository
public interface MovimientoRepository extends JpaRepository<Movimiento, Long> {

    List<Movimiento> findByFechaBetween(LocalDateTime inicio, LocalDateTime fin);

    List<Movimiento> findByUsuario(Usuario usuario);

    @Query("SELECT m FROM Movimiento m " +
           "WHERE m.fecha BETWEEN :inicio AND :fin " +
           "AND m.usuario = :usuario")
    List<Movimiento> findByFechaBetweenAndUsuario(
            @Param("inicio") LocalDateTime inicio,
            @Param("fin") LocalDateTime fin,
            @Param("usuario") Usuario usuario
    );
}

```

---

### repository/MovimientoDetalleRepository.java

java

```jsx
package com.logitrack.repository;

import com.logitrack.model.MovimientoDetalle;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

@Repository
public interface MovimientoDetalleRepository extends JpaRepository<MovimientoDetalle, Long> {
}

```

---

### repository/AuditoriaRepository.java

java

```jsx
package com.logitrack.repository;

import com.logitrack.model.Auditoria;
import com.logitrack.model.Usuario;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;

import java.time.LocalDateTime;
import java.util.List;

@Repository
public interface AuditoriaRepository extends JpaRepository<Auditoria, Long> {

    List<Auditoria> findByUsuario(Usuario usuario);

    List<Auditoria> findByOperacion(Auditoria.Operacion operacion);

    @Query("SELECT a FROM Auditoria a " +
           "WHERE a.fecha BETWEEN :inicio AND :fin")
    List<Auditoria> findByFechaBetween(
            @Param("inicio") LocalDateTime inicio,
            @Param("fin") LocalDateTime fin
    );

    @Query("SELECT a FROM Auditoria a " +
           "WHERE a.entidad = :entidad AND a.entidadId = :id")
    List<Auditoria> findByEntidadAndEntidadId(
            @Param("entidad") String entidad,
            @Param("id") Long id
    );
}

```

---

## **PASO 11 ‚Äì DTOs PARA MOVIMIENTOS**

### dto/MovimientoRequest.java

java

```jsx
package com.logitrack.dto;

import com.logitrack.model.Movimiento;
import jakarta.validation.constraints.*;
import lombok.*;

import java.util.List;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class MovimientoRequest {

    @NotNull
    private Movimiento.TipoMovimiento tipo;

    @Positive
    private Long usuarioId;

    private Long bodegaOrigenId;

    private Long bodegaDestinoId;

    @NotEmpty
    private List<DetalleMovimientoDTO> detalles;

    @Data
    @NoArgsConstructor
    @AllArgsConstructor
    public static class DetalleMovimientoDTO {

        @Positive
        private Long productoId;

        @Min(1)
        private Integer cantidad;
    }
}

```

---

### dto/MovimientoResponse.java

java

```jsx
package com.logitrack.dto;

import com.logitrack.model.Movimiento;
import lombok.*;

import java.time.LocalDateTime;
import java.util.List;

@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class MovimientoResponse {

    private Long id;
    private LocalDateTime fecha;
    private Movimiento.TipoMovimiento tipo;
    private String usuarioNombre;
    private String bodegaOrigen;
    private String bodegaDestino;
    private List<DetalleResponse> detalles;

    @Data
    @NoArgsConstructor
    @AllArgsConstructor
    public static class DetalleResponse {
        private String productoNombre;
        private Integer cantidad;
    }
}

```

---

## **PASO 12 ‚Äì SERVICIO DE MOVIMIENTOS (L√ìGICA DE NEGOCIO 100%)**

### service/MovimientoService.java

java

```jsx
package com.logitrack.service;

import com.logitrack.dto.*;
import com.logitrack.exception.*;
import com.logitrack.model.*;
import com.logitrack.repository.*;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.time.LocalDateTime;
import java.util.List;
import java.util.stream.Collectors;

@Service
@RequiredArgsConstructor
@Transactional
public class MovimientoService {

    private final MovimientoRepository movimientoRepo;
    private final MovimientoDetalleRepository detalleRepo;
    private final BodegaRepository bodegaRepo;
    private final ProductoRepository productoRepo;
    private final UsuarioRepository usuarioRepo;

    public MovimientoResponse registrar(MovimientoRequest request) {

        // üîπ Validar usuario
        Usuario usuario = usuarioRepo.findById(request.getUsuarioId())
                .orElseThrow(() ->
                        new ResourceNotFoundException("Usuario no encontrado: " + request.getUsuarioId()));

        // üîπ Validar bodegas seg√∫n tipo de movimiento
        Bodega origen = null;
        Bodega destino = null;

        if (request.getTipo() == Movimiento.TipoMovimiento.ENTRADA) {
            if (request.getBodegaOrigenId() != null)
                throw new BusinessException("ENTRADA no debe tener bodega origen");

            destino = bodegaRepo.findById(request.getBodegaDestinoId())
                    .orElseThrow(() -> new ResourceNotFoundException("Bodega destino no encontrada"));

        } else if (request.getTipo() == Movimiento.TipoMovimiento.SALIDA) {
            if (request.getBodegaDestinoId() != null)
                throw new BusinessException("SALIDA no debe tener bodega destino");

            origen = bodegaRepo.findById(request.getBodegaOrigenId())
                    .orElseThrow(() -> new ResourceNotFoundException("Bodega origen no encontrada"));

        } else if (request.getTipo() == Movimiento.TipoMovimiento.TRANSFERENCIA) {
            origen = bodegaRepo.findById(request.getBodegaOrigenId())
                    .orElseThrow(() -> new ResourceNotFoundException("Bodega origen no encontrada"));

            destino = bodegaRepo.findById(request.getBodegaDestinoId())
                    .orElseThrow(() -> new ResourceNotFoundException("Bodega destino no encontrada"));

            if (origen.getId().equals(destino.getId()))
                throw new BusinessException("Bodega origen y destino deben ser diferentes");
        }

        // üîπ Crear movimiento
        Movimiento movimiento = Movimiento.builder()
                .tipo(request.getTipo())
                .usuario(usuario)
                .bodegaOrigen(origen)
                .bodegaDestino(destino)
                .build();

        // üîπ Procesar detalles y actualizar stock
        for (MovimientoRequest.DetalleMovimientoDTO det : request.getDetalles()) {
            Producto producto = productoRepo.findById(det.getProductoId())
                    .orElseThrow(() ->
                            new ResourceNotFoundException("Producto no encontrado: " + det.getProductoId()));

            MovimientoDetalle detalle = MovimientoDetalle.builder()
                    .movimiento(movimiento)
                    .producto(producto)
                    .cantidad(det.getCantidad())
                    .build();

            movimiento.getDetalles().add(detalle);

            // üîπ Actualizar stock seg√∫n tipo
            if (request.getTipo() == Movimiento.TipoMovimiento.ENTRADA) {
                producto.setStock(producto.getStock() + det.getCantidad());

            } else if (request.getTipo() == Movimiento.TipoMovimiento.SALIDA
                    || request.getTipo() == Movimiento.TipoMovimiento.TRANSFERENCIA) {

                if (producto.getStock() < det.getCantidad()) {
                    throw new BusinessException("Stock insuficiente para producto: " + producto.getNombre());
                }

                producto.setStock(producto.getStock() - det.getCantidad());
            }
        }

        // üîπ Si es transferencia, aumentar stock en destino
        if (request.getTipo() == Movimiento.TipoMovimiento.TRANSFERENCIA) {
            for (MovimientoRequest.DetalleMovimientoDTO det : request.getDetalles()) {
                Producto p = productoRepo.findById(det.getProductoId()).get();
                p.setStock(p.getStock() + det.getCantidad());
            }
        }

        // üîπ Guardar movimiento
        Movimiento saved = movimientoRepo.save(movimiento);
        return toResponse(saved);
    }

    public List<MovimientoResponse> findByFechas(LocalDateTime inicio, LocalDateTime fin) {
        return movimientoRepo.findByFechaBetween(inicio, fin).stream()
                .map(this::toResponse)
                .collect(Collectors.toList());
    }

    public List<MovimientoResponse> findByUsuario(Long usuarioId) {
        Usuario usuario = usuarioRepo.findById(usuarioId)
                .orElseThrow(() -> new ResourceNotFoundException("Usuario no encontrado"));
        return movimientoRepo.findByUsuario(usuario).stream()
                .map(this::toResponse)
                .collect(Collectors.toList());
    }

    private MovimientoResponse toResponse(Movimiento m) {
        return MovimientoResponse.builder()
                .id(m.getId())
                .fecha(m.getFecha())
                .tipo(m.getTipo())
                .usuarioNombre(m.getUsuario().getNombreCompleto())
                .bodegaOrigen(m.getBodegaOrigen() != null ? m.getBodegaOrigen().getNombre() : null)
                .bodegaDestino(m.getBodegaDestino() != null ? m.getBodegaDestino().getNombre() : null)
                .detalles(m.getDetalles().stream()
                        .map(d -> new MovimientoResponse.DetalleResponse(
                                d.getProducto().getNombre(),
                                d.getCantidad()))
                        .collect(Collectors.toList()))
                .build();
    }
}

```

---

## **PASO 13 ‚Äì CONTROLADOR DE MOVIMIENTOS**

### controller/MovimientoController.java

java

```jsx
package com.logitrack.controller;

import com.logitrack.dto.*;
import com.logitrack.service.MovimientoService;
import io.swagger.v3.oas.annotations.*;
import io.swagger.v3.oas.annotations.tags.Tag;
import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;
import org.springframework.format.annotation.DateTimeFormat;
import org.springframework.http.*;
import org.springframework.web.bind.annotation.*;

import java.time.LocalDateTime;
import java.util.List;

@RestController
@RequestMapping("/api/movimientos")
@RequiredArgsConstructor
@Tag(name = "Movimientos", description = "Registro de entradas, salidas y transferencias")
public class MovimientoController {

    private final MovimientoService service;

    @PostMapping
    @Operation(summary = "Registrar un nuevo movimiento", description = "Crea un registro de entrada, salida o transferencia de productos")
    public ResponseEntity<MovimientoResponse> registrar(@Valid @RequestBody MovimientoRequest request) {
        MovimientoResponse response = service.registrar(request);
        return new ResponseEntity<>(response, HttpStatus.CREATED);
    }

    @GetMapping("/fechas")
    @Operation(summary = "Obtener movimientos por rango de fechas")
    public ResponseEntity<List<MovimientoResponse>> porFechas(
            @RequestParam @DateTimeFormat(iso = DateTimeFormat.ISO.DATE_TIME) LocalDateTime inicio,
            @RequestParam @DateTimeFormat(iso = DateTimeFormat.ISO.DATE_TIME) LocalDateTime fin) {
        return ResponseEntity.ok(service.findByFechas(inicio, fin));
    }

    @GetMapping("/usuario/{id}")
    @Operation(summary = "Obtener movimientos por usuario")
    public ResponseEntity<List<MovimientoResponse>> porUsuario(@PathVariable Long id) {
        return ResponseEntity.ok(service.findByUsuario(id));
    }
}

```

---

## **PASO 14 ‚Äì REPORTES AVANZADOS**

### dto/ReporteResumen.java

java

```jsx
package com.logitrack.dto;

import lombok.*;
import java.util.List;

@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class ReporteResumen {

    private List<StockPorBodega> stockPorBodega;
    private List<ProductoMovido> productosMasMovidos;
    private List<Producto> stockBajo;

    @Data
    @NoArgsConstructor
    @AllArgsConstructor
    public static class StockPorBodega {
        private String bodega;
        private Integer totalProductos;
        private Double valorTotal;
    }

    @Data
    @NoArgsConstructor
    @AllArgsConstructor
    public static class ProductoMovido {
        private String nombre;
        private Integer movimientos;
    }
}

```

---

### service/ReporteService.java

java

```jsx
package com.logitrack.service;

import com.logitrack.dto.ReporteResumen;
import com.logitrack.model.*;
import com.logitrack.repository.*;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Service;

import java.util.List;
import java.util.stream.Collectors;

@Service
@RequiredArgsConstructor
public class ReporteService {

    private final ProductoRepository productoRepo;
    private final MovimientoDetalleRepository detalleRepo;
    private final BodegaRepository bodegaRepo;

    public ReporteResumen generarResumen() {

        // Stock bajo (productos con stock < 10)
        List<Producto> stockBajo = productoRepo.findByStockLessThan(10);

        // Productos m√°s movidos (por cantidad total en movimientos)
        List<ReporteResumen.ProductoMovido> masMovidos = detalleRepo.findAll().stream()
                .collect(Collectors.groupingBy(
                        MovimientoDetalle::getProducto,
                        Collectors.summingInt(MovimientoDetalle::getCantidad)
                ))
                .entrySet().stream()
                .sorted((e1, e2) -> e2.getValue().compareTo(e1.getValue()))
                .limit(5)
                .map(e -> new ReporteResumen.ProductoMovido(e.getKey().getNombre(), e.getValue()))
                .collect(Collectors.toList());

        // Stock por bodega (simplificado: total productos y valor total en el sistema)
        List<ReporteResumen.StockPorBodega> stockBodegas = bodegaRepo.findAll().stream()
                .map(b -> {
                    int total = productoRepo.findAll().stream()
                            .mapToInt(Producto::getStock)
                            .sum();
                    double valor = productoRepo.findAll().stream()
                            .mapToDouble(p -> p.getStock() * p.getPrecio())
                            .sum();
                    return new ReporteResumen.StockPorBodega(b.getNombre(), total, valor);
                })
                .collect(Collectors.toList());

        return ReporteResumen.builder()
                .stockPorBodega(stockBodegas)
                .productosMasMovidos(masMovidos)
                .stockBajo(stockBajo)
                .build();
    }
}

```

---

### controller/ReporteController.java

java

```jsx
package com.logitrack.controller;

import com.logitrack.dto.ReporteResumen;
import com.logitrack.service.ReporteService;
import io.swagger.v3.oas.annotations.tags.Tag;
import lombok.RequiredArgsConstructor;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
@RequestMapping("/api/reportes")
@RequiredArgsConstructor
@Tag(name = "Reportes", description = "Consultas avanzadas y resumen")
public class ReporteController {

    private final ReporteService service;

    @GetMapping("/resumen")
    public ResponseEntity<ReporteResumen> resumen() {
        return ResponseEntity.ok(service.generarResumen());
    }

    @GetMapping("/stock-bajo")
    public ResponseEntity<?> stockBajo() {
        return ResponseEntity.ok(service.generarResumen().getStockBajo());
    }
}

```

---

## **PASO 15 ‚Äì AUDITOR√çA EN ACCI√ìN (PRUEBA)**

> La auditor√≠a se registra autom√°ticamente en cada INSERT, UPDATE, DELETE de cualquier entidad con @EntityListeners(AuditoriaListener.class)
A√±ade a Bodega, Producto, Movimiento:
> 

java

`@EntityListeners(AuditoriaListener.class)`

---

**FIN DEL D√çA 2**

> Entregable:
> 
> - Movimientos con stock autom√°tico
> - Transferencias entre bodegas
> - Auditor√≠a 100% autom√°tica
> - Reportes JSON completos
> - Filtros por fecha/usuario
> - Swagger actualizado

---

## **PASO 16 ‚Äì SERVICIO Y CONTROLADOR DE AUDITOR√çA**

### service/AuditoriaService.java

java

```jsx
package com.logitrack.service;

import com.logitrack.model.Auditoria;
import com.logitrack.repository.AuditoriaRepository;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Service;

import java.time.LocalDateTime;
import java.util.List;

@Service
@RequiredArgsConstructor
public class AuditoriaService {

    private final AuditoriaRepository repo;

    public List<Auditoria> todas() {
        return repo.findAll();
    }

    public List<Auditoria> porEntidad(String entidad, Long id) {
        return repo.findByEntidadAndEntidadId(entidad, id);
    }

    public List<Auditoria> porOperacion(Auditoria.Operacion op) {
        return repo.findByOperacion(op);
    }

    public List<Auditoria> porRango(LocalDateTime inicio, LocalDateTime fin) {
        return repo.findByFechaBetween(inicio, fin);
    }
}
```

---

### controller/AuditoriaController.java

java

```jsx
package com.logitrack.controller;

import com.logitrack.model.Auditoria;
import com.logitrack.service.AuditoriaService;
import io.swagger.v3.oas.annotations.tags.Tag;
import lombok.RequiredArgsConstructor;
import org.springframework.format.annotation.DateTimeFormat;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.time.LocalDateTime;
import java.util.List;

@RestController
@RequestMapping("/api/auditoria")
@RequiredArgsConstructor
@Tag(name = "Auditor√≠a", description = "Consulta de registros de auditor√≠a")
public class AuditoriaController {

    private final AuditoriaService service;

    @GetMapping
    public ResponseEntity<List<Auditoria>> todas() {
        return ResponseEntity.ok(service.todas());
    }

    @GetMapping("/entidad/{nombre}/{id}")
    public ResponseEntity<List<Auditoria>> porEntidad(
            @PathVariable String nombre,
            @PathVariable Long id) {
        return ResponseEntity.ok(service.porEntidad(nombre, id));
    }

    @GetMapping("/operacion/{op}")
    public ResponseEntity<List<Auditoria>> porOperacion(@PathVariable Auditoria.Operacion op) {
        return ResponseEntity.ok(service.porOperacion(op));
    }

    @GetMapping("/rango")
    public ResponseEntity<List<Auditoria>> porRango(
            @RequestParam @DateTimeFormat(iso = DateTimeFormat.ISO.DATE_TIME) LocalDateTime inicio,
            @RequestParam @DateTimeFormat(iso = DateTimeFormat.ISO.DATE_TIME) LocalDateTime fin) {
        return ResponseEntity.ok(service.porRango(inicio, fin));
    }
}
```

---

## **PASO 17 ‚Äì ENDPOINTS ADICIONALES DE REPORTES**

### controller/ReporteController.java (endpoints avanzados)

java

```jsx
package com.logitrack.controller;

import com.logitrack.dto.MovimientoResponse;
import com.logitrack.dto.ReporteResumen;
import com.logitrack.model.Movimiento;
import com.logitrack.repository.MovimientoRepository;
import com.logitrack.service.MovimientoService;
import com.logitrack.service.ReporteService;
import io.swagger.v3.oas.annotations.tags.Tag;
import lombok.RequiredArgsConstructor;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.util.Comparator;
import java.util.List;
import java.util.stream.Collectors;

@RestController
@RequestMapping("/api/reportes")
@RequiredArgsConstructor
@Tag(name = "Reportes", description = "Consultas avanzadas y resumen")
public class ReporteController {

    private final ReporteService reporteService;
    private final MovimientoRepository movimientoRepo;
    private final MovimientoService movimientoService;

    @GetMapping("/resumen")
    public ResponseEntity<ReporteResumen> resumen() {
        return ResponseEntity.ok(reporteService.generarResumen());
    }

    @GetMapping("/stock-bajo")
    public ResponseEntity<?> stockBajo() {
        return ResponseEntity.ok(reporteService.generarResumen().getStockBajo());
    }

    @GetMapping("/movimientos/ultimos")
    public ResponseEntity<List<MovimientoResponse>> ultimos() {
        List<Movimiento> lista = movimientoRepo.findAll().stream()
                .sorted(Comparator.comparing(Movimiento::getFecha).reversed())
                .limit(10)
                .collect(Collectors.toList());
        return ResponseEntity.ok(lista.stream()
                .map(movimientoService::toResponsePublic)
                .collect(Collectors.toList()));
    }
}
```

> Nota: Puedes extender con filtros por `bodegaId` y tipo (`ENTRADA`, `SALIDA`, `TRANSFERENCIA`) siguiendo el mismo patr√≥n con repositorio y `toResponsePublic`.

---

## **PASO 18 ‚Äì B√öSQUEDA COMBINADA DE MOVIMIENTOS**

### service/MovimientoService.java (b√∫squeda combinada)

java

```jsx
// Dentro de MovimientoService
public List<MovimientoResponse> search(
        Movimiento.TipoMovimiento tipo,
        Long usuarioId,
        Long bodegaId,
        LocalDateTime inicio,
        LocalDateTime fin
) {
    // Implementaci√≥n basada en filtros opcionales y mapeo a DTO
    return movimientoRepo.findAll().stream()
            .filter(m -> tipo == null || m.getTipo() == tipo)
            .filter(m -> usuarioId == null || (m.getUsuario() != null && m.getUsuario().getId().equals(usuarioId)))
            .filter(m -> bodegaId == null ||
                    (m.getBodegaOrigen() != null && m.getBodegaOrigen().getId().equals(bodegaId)) ||
                    (m.getBodegaDestino() != null && m.getBodegaDestino().getId().equals(bodegaId)))
            .filter(m -> inicio == null || !m.getFecha().isBefore(inicio))
            .filter(m -> fin == null || !m.getFecha().isAfter(fin))
            .sorted(Comparator.comparing(Movimiento::getFecha).reversed())
            .map(this::toResponsePublic)
            .collect(Collectors.toList());
}
```

---

### controller/MovimientoController.java (endpoint `/search`)

java

```jsx
@GetMapping("/search")
public ResponseEntity<List<MovimientoResponse>> search(
        @RequestParam(required = false) Movimiento.TipoMovimiento tipo,
        @RequestParam(required = false) Long usuarioId,
        @RequestParam(required = false) Long bodegaId,
        @RequestParam(required = false) @DateTimeFormat(iso = DateTimeFormat.ISO.DATE_TIME) LocalDateTime inicio,
        @RequestParam(required = false) @DateTimeFormat(iso = DateTimeFormat.ISO.DATE_TIME) LocalDateTime fin
) {
    return ResponseEntity.ok(service.search(tipo, usuarioId, bodegaId, inicio, fin));
}
```

---

## **PASO EXTRA ‚Äì ACTIVAR AUDITOR√çA EN M√ÅS ENTIDADES**

> Para trazabilidad completa, a√±ade `@EntityListeners(AuditoriaListener.class)` tambi√©n en:
> - `InventarioBodega.java`
> - `Usuario.java`
> - `MovimientoDetalle.java`

java

```jsx
import com.logitrack.config.AuditoriaListener;
import jakarta.persistence.EntityListeners;

@EntityListeners(AuditoriaListener.class)
public class InventarioBodega { /* ... */ }

@EntityListeners(AuditoriaListener.class)
public class Usuario { /* ... */ }

@EntityListeners(AuditoriaListener.class)
public class MovimientoDetalle { /* ... */ }
```